## 内容

## B tree
```
关键字集合分布在整颗树中；
任何一个关键字出现且只出现在一个结点中；
搜索有可能在非叶子结点结束(树中所有结点都存储数据，与B+树这一点不同)；
其搜索性能等价于在关键字全集内做一次二分查找
```
## Innodb的B+tree
```
1.B+树非叶子节点上是不存储数据的，仅存储键值，而 B 树节点中不仅存储键值，也会存储数据。
2.B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。
3.B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单
B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。
内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。
每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。
父节点存有右孩子的第一个元素的索引。
```
### 聚集索引
```
聚集索引 VS 非聚集索引
以 InnoDB 作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。
这是因为 InnoDB 是把数据存放在 B+ 树中的，而 B+ 树的键值就是主键，在 B+ 树的叶子节点中，存储了表中所有的数据。
这种以主键作为 B+ 树索引的键值而构建的 B+ 树索引，我们称之为聚集索引
以主键以外的列值作为键值构建的 B+ 树索引，我们称之为非聚集索引
```
### 索引
```
一：mysql的索引有:
Innodb使用的是B+tree
hash索引,全文索引，空间索引，逻辑又可以分为单列，复合，唯一，非唯一索引
索引使随机IO变成顺序IO,使得表的扫描速度变快。
mysql支持目前仅仅支持前导列
1.innodb目前使用的是聚集索引，将相关的数据保持在一起，叶子节点内可保存相邻近的记录
2.因为索引和数据存储在一块,会比非簇索引
对于复合索引(a,b,c)来说
where a=?
where a=? and b=?
where a=? and b=? and c=? 这三种情况只命中a的索引
3.范围查询
between and > < 范围查询导致范围，这个可能会导致全表扫描(IN不是范围查询)
4.inner join会比left join的效率更高，同时join表的数据不能太多
5.对于复合索引来说，如果某部分用到了范围的查询的话，那这个列以后的索引将不会被使用
二：如何创建索引
1.对于字符串来说，使用比较短的索引，使用前缀索引，字符串可以统计字符串长度的均值
2.索引基数，对于基数很小的列就不太适合建索引了
3.索引不应该建太多，会降低修改数据的性能,数据在更新数据的时候，会更改索引
4.尽量保证order的列和索引的列相同，要尽量避免文件排序
三:Explain的使用
查看扫描的行数和use index的情况 
四:索引的用法：
use index：在你查询语句表名的后面，添加use index来提供你希望mysql去参考的索引列表，就可以让mysql不再考虑其他可用的索引
IGNORE INDEX 提示会禁止查询优化器使用指定的索引。在具有多个索引的查询时，可以用来指定不需要优化器使用的那个索引，还可以在删除不必要的索引之前在查询中禁止使用该索引
force index：强制mysql使用一个特定的索引。一般情况下mysql会根据统计信息选择正确的索引，但是当查询优化器选择了错误的索引或根本没有使用索引的时候，这个提示将非常有用
```
* [参考文章](http://www.liuzk.com/410.html)