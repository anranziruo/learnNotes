## 内容

### 分库规则
```
分区规则有哈希分区和顺序分区
哈希分区的特点:离散度好，数据分布和业务无关,无法顺序访问
顺序分区的特点:离散度倾斜,和数据业务相关，可以顺序访问
```
#### 哈希分区
```
1.节点取余分区
使用特定的数据，如Redis的键或用户ID，再根据节点数量N使用公式: hash(key)%N计算出哈希值，用来决定数据映射到哪一个节点上
存在的问题:当节点数量变化时，如扩容或收缩节点，数据节点映射关系需要重新计算，会导致数据的重新迁移
这种方式的突出优点是简单性，常用于数据库的分库分表规则，一般采用预分区的方式，提前根据数据量规划好分区数，比如划分为512或1024张表，保证可支撑未来一段时间的数据量
2.一致性哈希分区
一致性哈希分区(Distributed Hash Table)实现思路是为系统中每个节点分配一个token，范围一般在0~232，这些token构成一个哈希环。数据读写执行节点查找操作时，先根据key计算hash值，然后顺时针找到第一个大于等于该哈希值的token节点
存在的问题:
加减节点会造成哈希环中部分数据无法命中，需要手动处理或者忽略这部分数据，因此一致性哈希常用于缓存场景。
·当使用少量节点时，节点变化将大范围影响哈希环中数据映射，因此这种方式不适合少量数据节点的分布式方案。
·普通的一致性哈希分区在增减节点时需要增加一倍或减去一半节点才能保证数据和负载的均衡
3.虚拟槽分区
虚拟槽分区巧妙地使用了哈希空间，使用分散度良好的哈希函数把所有 数据映射到一个固定范围的整数集合中，整数定义为槽(slot)。这个范围一般远远大于节点数，比如Redis Cluster槽范围是0~16383。槽是集群内数据管理和迁移的基本单位。采用大范围槽的主要目的是为了方便数据拆分和集群扩展。每个节点会负责一定数量的槽
Redis Cluser采用虚拟槽分区，所有的键根据哈希函数映射到0~16383整数槽内，计算公式:slot=CRC16(key)&16383。每一个节点负责维护一部分槽以及槽所映射的键值数据
如果有当前集群有5个节点，每个节点平均大约负责3276个槽,用CRC16(key)&16383将键映射到槽上
集群功能限制:
1.key批量操作支持有限。如mset、mget，目前只支持具有相同slot值的key执行批量操作
2.key事务操作支持有限。同理只支持多key在同一节点上的事务操作
3.key作为数据分区的最小粒度，因此不能将一个大的键值对象如hash、list等映射到不同的节点
4.不支持多数据库空间。单机下的Redis可以支持16个数据库，集群模式下只能使用一个数据库空间，即db0
5.复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构
```

#### 节点握手
```
节点握手是指一批运行在集群模式下的节点通过Gossip协议彼此通信，达到感知对方的过程。节点握手是集群彼此通信的第一步，由客户端发起命 令:cluster meet{ip}{port}
cluster meet命令是一个异步命令，执行之后立刻返回。内部发起与目标节点进行握手通信,cluster meet命令加入新节点，握手状态会通过消息在集群内传播，这样其他节点会自动发现新节点并发起握手流程,cluster nodes 命令确认六个节点组成集群，节点建立握手之后集群还不能正常工作，这时集群处于下线状态，所有的数据读写都被禁止,然后可以通过 cluster info获取集群状态,只有当16384个槽全部分配给节点后，集群才进入在线状态
```
#### 分配槽
```
1.Redis集群把所有的数据映射到16384个槽中。每个key会映射为一个固定的槽，只有当节点分配了槽，才能响应和这些槽关联的键命令。通过 cluster addslots命令为节点分配槽
2.比如说有三个主节点，这个时候应该要有三个丛节点作为备份。作为一个完整的集群，每个负责处理槽的 节点应该具有从节点，保证当它出现故障时可以自动进行故障转移。集群模 式下，Reids节点角色分为主节点和从节点。首次启动的节点和被分配槽的 节点都是主节点，从节点负责复制主节点槽信息和相关的数据。使用cluster replicate{nodeId}命令让一个节点成为从节点。其中命令执行必须在对应的从节点上执行，nodeId是要复制主节点的节点ID
```
### 节点通信

#### 通信流程
```
常见的元数据维护方式分为:集中式和P2P方式。Redis集群采用P2P的Gossip(流言)协议，Gossip协议工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息，这种方式类似流言传播.
过程说明:
1.集群中的每个节点都会单独开辟一个TCP通道，用于节点之间彼此通信，通信端口号在基础端口上加10000
2.每个节点在固定周期内通过特定规则选择几个节点发送ping消息
3.接收到ping消息的节点用pong消息作为响应
```
#### Gossip消息
```
Gossip协议的主要职责就是信息交换。信息交换的载体就是节点彼此发送的Gossip消息,常用的Gossip消息可分为:ping消息、pong消息、meet消息、fail消息等
meet消息:用于通知新节点加入。消息发送者通知接收者加入到当前集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的 ping、pong消息交换
ping消息:集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息。ping消息发送封装了自身节点和部分其他节点的状态数据
pong消息:当接收到ping、meet消息时，作为响应消息回复给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新
fail消息:当节点判定集群内另一个节点下线时，会向集群内广播一个fail消息，其他节点接收到fail消息之后把对应节点更新为下线状态
```
#### 节点选择
```
1.选择发送消息的节点数量:
集群内每个节点维护定时任务默认每秒执行10次，每秒会随机选取5个 节点找出最久没有通信的节点发送ping消息，用于保证Gossip信息交换的随机性。每100毫秒都会扫描本地节点列表，如果发现节点最近一次接受pong消息的时间大于cluster_node_timeout/2，则立刻发送ping消息，防止该节点信息太长时间未更新
2.消息数据量:
每个ping消息的数据量体现在消息头和消息体中，其中消息头主要占用空间的字段是myslots[CLUSTER_SLOTS/8]，占用2KB，这块空间占用相对固定。消息体会携带一定数量的其他节点信息用于信息交换
```
### 集群伸缩
```
Redis集群提供了灵活的节点扩容和收缩方案。在不影响集群对外服务的情况下，可以为集群添加节点进行扩容也可以下线部分节点进行缩容,
Redis集群可以实现对节点的灵活上下线控制。其中原 理可抽象为槽和对应数据在不同节点之间灵活移动
```
#### 扩容集群
```
加入集群
1.新节点依然采用cluster meet命令加入到现有集群中。在集群内任意节点执行cluster meet命令让对应节点加入进来
2.集群内新旧节点经过一段时间的ping/pong消息通信之后，所有节点会发现新节点并将它们的状态保存到本地。
3.新节点刚开始都是主节点状态，但是由于没有负责的槽，所以不能接受任何读写操作
迁移槽和数据
1.槽是Redis集群管理数据的基本单位，首先需要为新节点制定槽的迁移计划，确定原有节点的哪些槽需要迁移到新节点。迁移计划需要确保每个节点负责相似数量的槽，
从而保证各节点的数据均匀
2.槽迁移流程
1)对目标节点发送cluster setslot{slot}importing{sourceNodeId}命令，让目标节点准备导入槽的数据。
2)对源节点发送cluster setslot{slot}migrating{targetNodeId}命令，让源节点准备迁出槽的数据。
3)源节点循环执行cluster getkeysinslot{slot}{count}命令，获取count个属于槽{slot}的键。
4)在源节点上执行migrate{targetIp}{targetPort}""0{timeout}keys{keys...} 命令，把获取的键通过流水线(pipeline)机制批量迁移到目标节点，
批量迁移版本的migrate命令在Redis3.0.6以上版本提供，之前的migrate命令只能单个键迁移。对于大量key的场景，批量键迁移将极大降低节点之间网络IO次数。
5)重复执行步骤3)和步骤4)直到槽下所有的键值数据迁移到目标节 点。
6)向集群内所有主节点发送cluster setslot{slot}node{targetNodeId}命令，通知槽分配给目标节点。为了保证槽节点映射变更及时传播，
需要遍历发送给所有主节点更新被迁移的槽指向新节点。
添加丛节点
1.使用cluster replicate{masterNodeId}命令为主节点添加对应从节点，注意在集群模式下slaveof添加从节点操作不再支持
```
#### 收缩集群
```
收缩集群意味着缩减规模,需要从现有集群中安全下线部分节点
1)首先需要确定下线节点是否有负责的槽，如果是，需要把槽迁移到其他节点，保证节点下线后整个集群槽节点映射的完整性。
2)当下线节点不再负责槽或者本身是从节点时，就可以通知集群内其他节点忘记下线节点，当所有的节点忘记该节点后可以正常关闭。
下线迁移槽
下线节点需要把自己负责的槽迁移到其他节点，原理与之前节点扩容的迁移槽过程一致
忘记节点
1.由于集群内的节点不停地通过Gossip消息彼此交换节点状态，因此需要通过一种健壮的机制让集群内所有节点忘记下线的节点。
也就是说让其他节点不再与要下线节点进行Gossip消息交换
2.Redis提供了cluster forget{downNodeId}命令实现该功能
3.线上操作不建议直接使用cluster forget命令下线节点，需要跟大量节点命令交互，实际操作起来过于繁琐并且容易遗漏forget节点。
建议使用redis- trib.rb del-node{host:port}{downNodeId}命令
```
### 请求路由

#### 请求重定向
```
1.在集群模式下，Redis接收任何键相关命令时首先计算键对应的槽，再根据槽找出所对应的节点，如果节点是自身，则处理键命令;否则回复 MOVED重定向错误，通知客户端请求正确的节点。这个过程称为MOVED重定向.MOVED{slot}{ip}{port}格式重定向信息
2.重定向信息包含了键所对应的槽以及负责该槽的节点地址，根据这些信息客户端就可以向正确的节点发起请求
键命令执行步骤主要分两步:计算槽，查找槽所对应的节点。
计算槽:计算键所对应的槽。根据键的有效部分使用CRC16函数计算出散列值，再取对16383的余数，使每个键都可以映射到0~16383槽范围内
Redis计算得到键对应的槽后，需要查找槽所对应的节点。集群内通过消息交换每个节点都会知道所有节点的槽信息，内部保存在clusterState结构中
```
#### smart客户端
```
1.Smart客户端通过在内部维护slot→node的映射关系，本地就可实现键到节点的查找，从而保证IO效率的最大化，而MOVED重定向负责协助Smart客户端更新slot→node映射
键命令执行流程:
1.计算slot并根据slots缓存获取目标节点连接，发送命令
2.如果出现连接错误，使用随机连接重新执行键命令，每次命令重试对redi-rections参数减1
3.捕获到MOVED重定向错误，使用cluster slots命令更新slots缓存
4.重复执行1)~3)步，直到命令执行成功，或者当redirections<=0时抛出异常
```
#### ASK重定向
```
Redis集群支持在线迁移槽(slot)和数据来完成水平伸缩，当slot对应 的数据从源节点到目标节点迁移过程中，客户端需要做到智能识别，保证键命令可正常执行。例如当一个slot数据从源节点迁移到目标节点时，期间可能出现一部分数据在源节点，而另一部分在目标节点
重定向流程:
1.客户端根据本地slots缓存发送命令到源节点，如果存在键对象则直 接执行并返回结果给客户端。
2.如果键对象不存在，则可能存在于目标节点，这时源节点会回复ASK重定向异常。格式如下:(error)ASK{slot}{targetIP}:{targetPort}
3.客户端从ASK重定向异常提取出目标节点信息，发送asking命令到目 标节点打开客户端连接标识，再执行键命令。如果存在则执行，不存在则返回不存在信息
同move重定向的区别:
SK与MOVED虽然都是对客户端的重定向控制，但是有着本质区别。 ASK重定向说明集群正在进行slot数据迁移，
客户端无法知道什么时候迁移完成，因此只能是临时性的重定向，客户端不会更新slots缓存。
但是MOVED重定向说明键对应的槽已经明确指定到新的节点，因此需要更新slots缓存
```
### 故障转移

#### 主观下线


