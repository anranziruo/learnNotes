## 内容

### 分库规则
```
分区规则有哈希分区和顺序分区
哈希分区的特点:离散度好，数据分布和业务无关,无法顺序访问
顺序分区的特点:离散度倾斜,和数据业务相关，可以顺序访问
```
#### 哈希分区
```
1.节点取余分区
使用特定的数据，如Redis的键或用户ID，再根据节点数量N使用公式: hash(key)%N计算出哈希值，用来决定数据映射到哪一个节点上
存在的问题:当节点数量变化时，如扩容或收缩节点，数据节点映射关系需要重新计算，会导致数据的重新迁移
这种方式的突出优点是简单性，常用于数据库的分库分表规则，一般采用预分区的方式，提前根据数据量规划好分区数，比如划分为512或1024张表，保证可支撑未来一段时间的数据量
2.一致性哈希分区
一致性哈希分区(Distributed Hash Table)实现思路是为系统中每个节点分配一个token，范围一般在0~232，这些token构成一个哈希环。数据读写执行节点查找操作时，先根据key计算hash值，然后顺时针找到第一个大于等于该哈希值的token节点
存在的问题:
加减节点会造成哈希环中部分数据无法命中，需要手动处理或者忽略这部分数据，因此一致性哈希常用于缓存场景。
·当使用少量节点时，节点变化将大范围影响哈希环中数据映射，因此这种方式不适合少量数据节点的分布式方案。
·普通的一致性哈希分区在增减节点时需要增加一倍或减去一半节点才能保证数据和负载的均衡
3.虚拟槽分区
虚拟槽分区巧妙地使用了哈希空间，使用分散度良好的哈希函数把所有 数据映射到一个固定范围的整数集合中，整数定义为槽(slot)。这个范围一般远远大于节点数，比如Redis Cluster槽范围是0~16383。槽是集群内数据管理和迁移的基本单位。采用大范围槽的主要目的是为了方便数据拆分和集群扩展。每个节点会负责一定数量的槽
Redis Cluser采用虚拟槽分区，所有的键根据哈希函数映射到0~16383整数槽内，计算公式:slot=CRC16(key)&16383。每一个节点负责维护一部分槽以及槽所映射的键值数据
如果有当前集群有5个节点，每个节点平均大约负责3276个槽,用CRC16(key)&16383将键映射到槽上
集群功能限制:
1.key批量操作支持有限。如mset、mget，目前只支持具有相同slot值的key执行批量操作
2.key事务操作支持有限。同理只支持多key在同一节点上的事务操作
3.key作为数据分区的最小粒度，因此不能将一个大的键值对象如hash、list等映射到不同的节点
4.不支持多数据库空间。单机下的Redis可以支持16个数据库，集群模式下只能使用一个数据库空间，即db0
5.复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构
```

#### 节点握手
```
节点握手是指一批运行在集群模式下的节点通过Gossip协议彼此通信，达到感知对方的过程。节点握手是集群彼此通信的第一步，由客户端发起命 令:cluster meet{ip}{port}
cluster meet命令是一个异步命令，执行之后立刻返回。内部发起与目标节点进行握手通信,cluster meet命令加入新节点，握手状态会通过消息在集群内传播，这样其他节点会自动发现新节点并发起握手流程,cluster nodes 命令确认六个节点组成集群，节点建立握手之后集群还不能正常工作，这时集群处于下线状态，所有的数据读写都被禁止,然后可以通过 cluster info获取集群状态,只有当16384个槽全部分配给节点后，集群才进入在线状态
```
#### 分配槽
```
1.Redis集群把所有的数据映射到16384个槽中。每个key会映射为一个固定的槽，只有当节点分配了槽，才能响应和这些槽关联的键命令。通过 cluster addslots命令为节点分配槽
2.比如说有三个主节点，这个时候应该要有三个丛节点作为备份。作为一个完整的集群，每个负责处理槽的 节点应该具有从节点，保证当它出现故障时可以自动进行故障转移。集群模 式下，Reids节点角色分为主节点和从节点。首次启动的节点和被分配槽的 节点都是主节点，从节点负责复制主节点槽信息和相关的数据。使用cluster replicate{nodeId}命令让一个节点成为从节点。其中命令执行必须在对应的从节点上执行，nodeId是要复制主节点的节点ID
```
### 节点通信

#### 通信流程
```
常见的元数据维护方式分为:集中式和P2P方式。Redis集群采用P2P的Gossip(流言)协议，Gossip协议工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息，这种方式类似流言传播.
过程说明:
1.集群中的每个节点都会单独开辟一个TCP通道，用于节点之间彼此通信，通信端口号在基础端口上加10000
2.每个节点在固定周期内通过特定规则选择几个节点发送ping消息
3.接收到ping消息的节点用pong消息作为响应
```
#### Gossip消息
```
Gossip协议的主要职责就是信息交换。信息交换的载体就是节点彼此发送的Gossip消息,常用的Gossip消息可分为:ping消息、pong消息、meet消息、fail消息等
meet消息:用于通知新节点加入。消息发送者通知接收者加入到当前集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的 ping、pong消息交换
ping消息:集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息。ping消息发送封装了自身节点和部分其他节点的状态数据
pong消息:当接收到ping、meet消息时，作为响应消息回复给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新
fail消息:当节点判定集群内另一个节点下线时，会向集群内广播一个fail消息，其他节点接收到fail消息之后把对应节点更新为下线状态
```
#### 节点选择
```
1.选择发送消息的节点数量:
集群内每个节点维护定时任务默认每秒执行10次，每秒会随机选取5个 节点找出最久没有通信的节点发送ping消息，用于保证Gossip信息交换的随机性。每100毫秒都会扫描本地节点列表，如果发现节点最近一次接受pong消息的时间大于cluster_node_timeout/2，则立刻发送ping消息，防止该节点信息太长时间未更新
2.消息数据量:
每个ping消息的数据量体现在消息头和消息体中，其中消息头主要占用空间的字段是myslots[CLUSTER_SLOTS/8]，占用2KB，这块空间占用相对固定。消息体会携带一定数量的其他节点信息用于信息交换
```