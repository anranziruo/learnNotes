### 内容

```
图G=(V, E)来说，其中V是结点的集合,成为顶点.E是顶点对的集合成为边
可以有两种标准的表示方法，一个是邻接矩阵，另一个是邻接链表，这两种方法都可以表示有向图和无向图
```
### 有向图(邻接矩阵)
```
邻接矩阵是用两个数组来表示一个图：一个一维数组用来存储每个顶点的信息；一个二维数组（即邻接矩阵）用来存储图中的边或弧信息。对于图G =(V, E)来说，邻接矩阵matrix是一个|V|*|V|的方阵，假设1 <= i, j <= |V|，如果matrix[i][j] == 0，则表示顶点i和顶点j之间没有边相连
一个图结构中包含两个数组，一个顶点表和一个用来存储图中边或弧信息的二维数组
邻接矩阵创建图的V平方和V平方的时间来初始化
```
### 无向图(邻接链表)
```
邻接链表是一种不错的图存储结构，由于它在表示稀疏图的时候非常紧凑而成为通常的选择。对于图G =(V, E)来说，在其邻接链表表示中，每个结点对应一条链表，因此这个图里有V条链表。假设用一个V维的数组Adj来存储这V条链表，且Adj[i]表示的是结点i对应的链表，那么Adj[i]这条链表里存储的就是所有与节点i之间有边相连的结点，即与结点i相邻的结点
首先要明确，一个图包含了一个顶点表，而顶点表里的每一项又包含一个边表：
顶点表：该表包含了图里的所有顶点，顶点表的每一项用于存储该顶点的属性（例如该结点对应的值），以及指向其边表的第一个结点的指针。
边表：某个顶点的边表存放了与其相邻的结点。
明确上述两个结构后，就具体介绍这两个表里每一项的数据结构：
边表结点：边表里的每一项叫做边表结点，它包含adjId、weight和next两个区域。其中，adjId存储的是某顶点的邻接点在顶点表中的下标值，weight存储了这条边的权重，而next则是一个指向边表中下一个结点的指针
```
### 图的遍历(深度优先搜索)
```
广度优先搜索（BFS）是图的另一种遍历方式，与DFS相对，是以广度优先进行搜索。简言之就是先访问图的顶点，然后广度优先访问其邻接点，然后再依次进行被访问点的邻接点，一层一层访问，直至访问完所有点，遍历结束

深度优先搜索的过程类似于树的先序遍历，首先从例子中体会深度优先搜索。例如图 1 是一个无向图，采用深度优先算法遍历这个图的过程为：
首先任意找一个未被遍历过的顶点，例如从 V1 开始，由于 V1 率先访问过了，所以，需要标记 V1 的状态为访问过；
然后遍历 V1 的邻接点，例如访问 V2 ，并做标记，然后访问 V2 的邻接点，例如 V4 （做标记），然后 V8 ，然后 V5 ；
当继续遍历 V5 的邻接点时，根据之前做的标记显示，所有邻接点都被访问过了。此时，从 V5 回退到 V8 ，看 V8 是否有未被访问过的邻接点，如果没有，继续回退到 V4 ， V2 ， V1 ；
通过查看 V1 ，找到一个未被访问过的顶点 V3 ，继续遍历，然后访问 V3  邻接点 V6 ，然后 V7 ；
由于 V7 没有未被访问的邻接点，所有回退到 V6 ，继续回退至 V3 ，最后到达 V1 ，发现没有未被访问的；
最后一步需要判断是否所有顶点都被访问，如果还有没被访问的，以未被访问的顶点为第一个顶点，继续依照上边的方式进行遍历

深搜优缺点
优点
1、能找出所有解决方案
2、优先搜索一棵子树，然后是另一棵，所以和广搜对比，有着内存需要相对较少的优点
缺点
1、要多次遍历，搜索所有可能路径，标识做了之后还要取消。
2、在深度很大的情况下效率不高
```
### 图的遍历(广度优先搜索)
```
广度优先搜索类似于树的层次遍历。从图中的某一顶点出发，遍历每一个顶点时，依次遍历其所有的邻接点，然后再从这些邻接点出发，同样依次访问它们的邻接点。按照此过程，直到图中所有被访问过的顶点的邻接点都被访问到。
最后还需要做的操作就是查看图中是否存在尚未被访问的顶点，若有，则以该顶点为起始点，重复上述遍历的过程。
广搜优缺点
优点
1、对于解决最短或最少问题特别有效，而且寻找深度小
2、每个结点只访问一遍，结点总是以最短路径被访问，所以第二次路径确定不会比第一次短
缺点
1、内存耗费量大（需要开大量的数组单元用来存储状态）
```

