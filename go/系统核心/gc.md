# 垃圾回收机制

## 垃圾回收方法

### 引用计数
每个对象维护一个引用计数，当引用该对象的对象被销毁或更新时被引用对象的引用计数自动减一，当被引用对象被创建或被赋值给其他对象时引用计数自动加一。当引用计数为0时则立即回收对象。
这种方法的优点是实现简单，并且内存的回收很及时。这种算法在内存比较紧张和实时性比较高的系统中使用的比较广泛，如ios cocoa框架，php，python等。简单引用计数算法也有明显的缺点：
频繁更新引用计数降低了性能。一种简单的解决方法就是编译器将相邻的引用计数更新操作合并到一次更新；还有一种方法是针对频繁发生的临时变量引用不进行计数，而是在引用达到0时通过扫描堆栈确认是否还有临时对象引用而决定是否释放。等等还有很多其他方法，具体可以参考这里。
循环引用问题。当对象间发生循环引用时引用链中的对象都无法得到释放。最明显的解决办法是避免产生循环引用，如cocoa引入了strong指针和weak指针两种指针类型。或者系统检测循环引用并主动打破循环链。当然这也增加了垃圾回收的复杂度。

### 标记-清除
* 该方法分为两步，标记从根变量开始迭代得遍历所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为“被引用”；标记完成后进行清除操作，对没有标记过的内存进行回收（回收同时可能伴有碎片整理操作）。这种方法解决了引用计数的不足，但是也有比较明显的问题：每次启动垃圾回收都会暂停当前所有的正常代码执行，回收是系统响应能力大大降低！当然后续也出现了很多mark&sweep算法的变种（如三色标记法）优化了这个问题。
* 此算法主要有两个主要的步骤：
    标记(Mark phase)
    清除(Sweep phase)
    第一步，找出不可达的对象，然后做上标记。
    第二步，回收标记好的对象。
* 备注:
```
标记-清扫(Mark And Sweep)算法这种算法虽然非常的简单，但是还存在一些问题：
STW，stop the world；让程序暂停，程序出现卡顿。
标记需要扫描整个heap
清除数据会产生heap碎片
这里面最重要的问题就是：mark-and-sweep 算法会暂停整个程序
```

### 分代收集（generation）
经过大量实际观察得知，在面向对象编程语言中，绝大多数对象的生命周期都非常短。分代收集的基本思想是，将堆划分为两个或多个称为 代（generation）的空间。新创建的对象存放在称为 新生代（young generation）中（一般来说，新生代的大小会比 老年代小很多），随着垃圾回收的重复执行，生命周期较长的对象会被 提升（promotion）到老年代中。因此，新生代垃圾回收和老年代垃圾回收两种不同的垃圾回收方式应运而生，分别用于对各自空间中的对象执行垃圾回收。新生代垃圾回收的速度非常快，比老年代快几个数量级，即使新生代垃圾回收的频率更高，执行效率也仍然比老年代垃圾回收强，这是因为大多数对象的生命周期都很短，根本无需提升到老年代。

### golang的垃圾回收机制
![示例图](https://github.com/zhangchao1/learnNotes/blob/master/assets/go/20160816013851168.jpg)
golang的三色标记清除法
三色标记的基本逻辑: 
* 起初所有对象都是白色。 
* 扫描找出所有可达对象标记为灰色，翻入待处理队列。 
* 从队列中提取灰色对象，将其引用的对象标记为灰色放入队列。自身标记为黑色。 
* 写屏障件事所有对象内存修改，重新标色或放回队列。

### 三色：将GC中的对象按照搜索情况分成三种：
1.黑色：对象在这次GC中已标记，且这个对象包含的子对象也已标记
2.灰色：对象在这次GC中已标记，但这个对象包含的子对象未标记
3.白色：对象在这次GC中未标记。

### golang标记的原理
[参考文章](https://i6448038.github.io/2019/03/04/golang-garbage-collector/)

### golang的三色标记法：
1.程序创建的对象都标记为白色
2.gc开始：扫描所有可到达的对象，标记为灰色
3.从灰色对象中找到其引用对象标记为灰色，把灰色对象本身标记为黑色
4.监视对象中的内存修改，并持续上一步的操作，直到灰色标记的对象不存在
最后gc回收白色对象
最后，将所有黑色对象变为白色，并重复以上所有过程。
重点是:清除操作和用户逻辑可以并发

process新生成对象的时候，GC该如何操作呢:
Golang为了解决这个问题，引入了写屏障这个机制。
写屏障：该屏障之前的写操作和之后的写操作相比，先被系统其它组件感知。
通俗的讲：就是在gc跑的过程中，可以监控对象的内存修改，并对对象进行重新标记。(实际上也是超短暂的stw，然后对对象进行标记)
在上述情况中，新生成的对象，一律都标位灰色！

